git-cherry-pick данная программма подходит для того чтоб, применять изменения внесенные некоторым существующими коммитами.

Учитывая один или несколько существующих коммитов, примените изменения, которые вносит каждый, записывая новый коммит для каждого. Это требует, чтобы ваше рабочее дерево было чистым (без изменений из фиксации HEAD).

Когда не очевидно, как применить изменение, происходит следующее:
1.Текущая ветвь и HEADуказатель остаются на последнем успешно сделанном коммите.
2.Ссылка CHERRY_PICK_HEADуказывает на фиксацию, которая внесла изменение, которое трудно применить.
3.Пути, в которых изменения применены корректно, обновляются как в индексном файле, так и в вашем рабочем дереве.
4.Для конфликтующих путей файл индекса записывает до трех версий, как описано в разделе «TRUE MERGE» git-merge. Файлы рабочего дерева будут включать описание конфликта, заключенное в квадратные скобки обычными маркерами конфликта <<<<<<<и расширением >>>>>>>.
5.Никаких других модификаций не делается.

<commit>
Обязуется выбирать вишни. Для более полного списка способов написания коммитов см. gitrevisions. Можно передавать наборы коммитов, но по умолчанию обход не выполняется, как если бы --no-walkбыла указана опция, см. git-rev-list. Обратите внимание, что указание диапазона приведет к тому, что все аргументы <commit>…​ будут переданы в один обход ревизии (см. более поздний пример, в котором используется maint master..next ).

-e
--edit
С этой опцией git cherry-pick позволит вам отредактировать сообщение коммита перед фиксацией.

--cleanup=<mode>
Этот параметр определяет, как сообщение фиксации будет очищаться перед передачей в механизм фиксации. См. git-commit для более подробной информации. В частности, если для <mode> задано значение scissors, ножницы будут добавлены MERGE_MSGперед передачей в случае конфликта.

-x
При записи коммита добавьте строку «(выбрано из коммита…​)» к исходному сообщению коммита, чтобы указать, из какого коммита было выбрано это изменение. Это делается только для выбора вишни без конфликтов. Не используйте эту опцию, если вы выбираете вишни из своей частной ветки, потому что информация бесполезна для получателя. Если, с другой стороны, вы выбираете между двумя общедоступными ветвями (например, портируете исправление в обслуживающую ветку для более старого выпуска из ветки разработки), добавление этой информации может быть полезным.

-r
Раньше считалось, что команда по умолчанию выполняет -x описанное выше и -rдолжна была отключить ее. Теперь по умолчанию не делать этого, -xпоэтому эта опция не работает.

-m <parent-number>
--mainline <parent-number>
Обычно вы не можете выбрать слияние, потому что вы не знаете, какую сторону слияния следует считать основной линией. Эта опция задает номер родителя (начиная с 1) основной ветки и позволяет функции Cherry-pick воспроизвести изменение относительно указанного родителя.

-n
--no-commit
Обычно команда автоматически создает последовательность коммитов. Этот флаг применяет изменения, необходимые для выбора каждого именованного коммита в вашем рабочем дереве и индексе, без каких-либо коммитов. Кроме того, при использовании этой опции ваш индекс не обязательно должен совпадать с фиксацией HEAD. Выбор вишни выполняется против начального состояния вашего индекса.

Это полезно, когда вы выбираете несколько коммитов для вашего индекса подряд.

-s
--signoff
Добавьте Signed-off-byтрейлер в конце сообщения фиксации. См. опцию signoff в git-commit для получения дополнительной информации.

-S[<keyid>]
--gpg-sign[=<keyid>]
--no-gpg-sign
GPG-знак фиксирует. Аргумент keyidявляется необязательным и по умолчанию соответствует идентификатору коммиттера; если он указан, он должен быть прикреплен к опции без пробела. --no-gpg-signполезно отменить как commit.gpgSignконфигурационную переменную, так и более ранние --gpg-sign.

--ff
Если текущий HEAD совпадает с родителем выбранного коммита, то будет выполнена быстрая перемотка вперед к этому коммиту.

--allow-empty
По умолчанию выборка пустого коммита завершится ошибкой, что указывает на то, что требуется явный вызов git commit --allow-empty. Этот параметр переопределяет это поведение, позволяя автоматически сохранять пустые коммиты при выборе вишни. Обратите внимание, что при включении "--ff" пустые коммиты, отвечающие требованию "быстрой перемотки вперед", будут сохранены даже без этой опции. Также обратите внимание, что при использовании этой опции сохраняются только те коммиты, которые изначально были пустыми (т. е. коммит записал то же дерево, что и его родитель). Коммиты, ставшие пустыми из-за предыдущего коммита, удаляются. Чтобы принудительно включить эти коммиты, используйте --keep-redundant-commits.

--allow-empty-message
По умолчанию выборка коммита с пустым сообщением завершится ошибкой. Этот параметр переопределяет это поведение, позволяя выбирать коммиты с пустыми сообщениями.

--keep-redundant-commits
Если выбранный коммит дублирует коммит, который уже есть в текущей истории, он станет пустым. По умолчанию эти избыточные фиксации вызывают cherry-pickостановку, чтобы пользователь мог проверить фиксацию. Этот параметр переопределяет это поведение и создает пустой объект фиксации. Подразумевает --allow-empty.

--strategy=<strategy>
Используйте данную стратегию слияния. Следует использовать только один раз. Подробнее см. в разделе MERGE STRATEGIES в git-merge.

-X<option>
--strategy-option=<option>
Передайте параметр, специфичный для стратегии слияния, в стратегию слияния. Подробности смотрите в git-merge.

--rerere-autoupdate
--no-rerere-autoupdate
Разрешить механизму rerere обновить индекс с результатом автоматического разрешения конфликтов, если это возможно.